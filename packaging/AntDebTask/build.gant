//  Gant -- A Groovy way of scripting Ant tasks.
//
//  Copyright Â© 2007-9 Russel Winder
//
//  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
//  compliance with the License. You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software distributed under the License is
//  distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied. See the License for the specific language governing permissions and limitations under the
//  License.
//
//  Author : Russel Winder <russel.winder@concertant.com>

//  TODO : Find a way of selecting this value from the Gradle build file.

gantVersion = '1.9.1-SNAPSHOT'

final packageName = 'gant-standalone'
final section = 'devel'
final priority = 'optional'
final architecture = 'all'
final homepage = 'http://gant.codehaus.org/' 

final installPrefixBase = 'usr/share/gant'

final antlibXMLns = 'antlib:org.apache.maven.artifact.ant'
final distributionURL = 'https://dav.codehaus.org/dist/gant/'

//  Use the ant-deb-task from Marius Scurtescu <marius.scurtescu@gmail.com> to create a deb file.
//  Assume the ant-deb.jar file is in ~/.groovy/lib.

ant.taskdef ( resource : 'ant_deb_task.properties' , classpath : [ System.properties.'user.home' , '.groovy' , 'lib' , 'ant-deb.jar' ].join ( System.properties.'file.separator' ) )

final debsDirectory = 'debs'
final distDirectory = 'dist'
final expandDirectory = distDirectory + '/gant-' + gantVersion

includeTargets << gant.targets.Clean
cleanPattern << '**/*~'
cleanDirectory << [ debsDirectory , distDirectory ]

includeTool << gant.tools.Execute

theSynopsis = 'Gant -- Groovy scripting of Ant tasks.' 
theWords = """
Gant is a tool for scripting Ant tasks using Groovy instead of XML to specify
the logic. A Gant specification is just a Groovy script and so can bring all
the power of Groovy to bear directly, something not possible with Ant scripts.
Whilst it might be seen as a competitor to Ant, Gant relies on all the Ant 
tasks for the complex actions, so it is really an alternative way of doing
builds using Ant, but using a programming language rather than XML to specify
the rules.
.
Homepage: ${homepage}
"""
  
target ( debFiles : 'Create the deb file of the distribution.' ) {
  execute.shell ( "cd ../.. && gradle standaloneBinTgz" )
  mkdir ( dir : distDirectory )
  execute.shell ( "cd ${distDirectory} && tar xvf ../../../build/gant-1.10.0-SNAPSHOT.tgz")
  mkdir ( dir : debsDirectory )
  ////  Why is the ant. needed here ??????
  ant.deb ( todir : debsDirectory , 'package' : packageName , section : section , priority : priority , architecture : architecture ,
        depends : 'java2-runtime', postinst : 'postinst' , prerm : 'prerm' ) {
    version ( upstream : gantVersion )
    maintainer ( name : 'Russel Winder' , email : 'russel.winder@concertant.com' )
    //homepage ( homepage )
    description ( synopsis : theSynopsis , theWords.replace ( '''
.
''' , '''
.
This package provides a self-contained installation of Gant that does not depend
on a separate installation of Groovy -- all the jars needed for Gant to run are
included in the package.
.
''' ) )
    tarfileset ( file : 'gant' , prefix : installPrefixBase + '/bin' , filemode : '755' )
    tarfileset ( file : [ expandDirectory , 'bin' , 'startGroovy' ].join ( '/' ) , prefix : installPrefixBase + '/bin' , filemode : '644' )
    tarfileset ( file : [ expandDirectory , 'conf' , 'gant-starter.conf' ].join ( '/' ) , prefix : installPrefixBase + '/conf' )
    tarfileset ( dir : [ expandDirectory , 'lib'].join (  '/' ) , includes : '*.jar' , prefix : installPrefixBase + '/lib' )
  }
}

target ( uploadDistribution : 'Upload the deb files to Codehaus.' ) {
  depends ( debFiles )
  "${antlibXMLns}:dependencies" ( pathId :  'slidePathId' ) {
    dependency ( groupId : 'slide' , artifactId : 'slide-webdavlib' , version : '2.1' )
  }
  def loader = getClass ( ).getClassLoader ( )
  def path = path ( refid : 'slidePathId' )
  ( path.list ( ) as List ).each { location -> loader.addURL ( new URL ( 'file://' + location ) ) }
  def settings =  ( new XmlSlurper ( ) ).parse ( System.properties.'user.home' + '/.m2/settings.xml' ).servers.server.find { item -> item.id == 'codehaus.org' }
  def credentials =  loader.loadClass ( 'org.apache.commons.httpclient.UsernamePasswordCredentials' ).getConstructor ( String , String ).newInstance ( settings.username.toString ( ) , settings.password.toString ( ) )
  //  Have to put resource in the binding so that the Closures can access it.
  resource = loader.loadClass ( 'org.apache.webdav.lib.WebdavResource' ).getConstructor ( String ,  loader.loadClass ( 'org.apache.commons.httpclient.Credentials' ) , boolean ).newInstance ( distributionURL , credentials , true )
  if ( resource.statusCode != 200 ) { println ( 'Failed to open ' + distributionURL ) }
  else {
    final serverUploadProducts = [:]
    final serverDistributionsDirectory = 'debs'
    ( new File ( debsDirectory ) ).eachFile { file -> serverUploadProducts[ file.path ] = serverDistributionsDirectory + '/' + file.name
    }
    serverUploadProducts.each { source , destination ->
      def serverPath = resource.path + '/' + destination
      print ( 'Uploading ' + source + ' -> ' + destination + ' : ' )
      def result = 'Failed.'
      if ( resource.putMethod ( serverPath , new File ( source ) ) ) { result = 'OK.' }
      println ( result + ' Status : ' + resource.statusMessage )
    }
  }
  if ( resource != null ) { resource.close ( ) }
}

setDefaultTarget ( debFiles )
